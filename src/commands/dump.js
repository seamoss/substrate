import { Command } from 'commander';
import { getDb } from '../db/local.js';
import { existsSync, mkdirSync, writeFileSync } from 'fs';
import { dirname, resolve } from 'path';
import { success, error, info, dim } from '../lib/output.js';

function findWorkspaceForCwd() {
  const db = getDb();
  const cwd = process.cwd();

  const mounts = db.prepare('SELECT * FROM mounts ORDER BY length(path) DESC').all();

  for (const mount of mounts) {
    if (cwd.startsWith(mount.path)) {
      return {
        workspace: db.prepare('SELECT * FROM workspaces WHERE id = ?').get(mount.workspace_id),
        mount
      };
    }
  }

  return { workspace: null, mount: null };
}

function formatDate(isoString) {
  return new Date(isoString).toLocaleDateString('en-US', {
    year: 'numeric',
    month: 'short',
    day: 'numeric'
  });
}

export const dumpCommand = new Command('dump')
  .description('Export all project context to a markdown file')
  .option('-o, --output <path>', 'Output file path', '.substrate/CONTEXT.md')
  .option('-w, --workspace <name>', 'Workspace name')
  .option('--no-links', 'Exclude relationship links')
  .option('--flat', 'Flat format without sections')
  .action((options) => {
    const db = getDb();

    let workspace, mount;
    if (options.workspace) {
      workspace = db.prepare('SELECT * FROM workspaces WHERE name = ?').get(options.workspace);
      if (!workspace) {
        error(`Workspace '${options.workspace}' not found`);
        process.exit(1);
      }
    } else {
      const result = findWorkspaceForCwd();
      workspace = result.workspace;
      mount = result.mount;
      if (!workspace) {
        error('No workspace found for current directory');
        process.exit(1);
      }
    }

    // Get all context
    const items = db.prepare(`
      SELECT * FROM context
      WHERE workspace_id = ? AND deleted_at IS NULL
      ORDER BY
        CASE type
          WHEN 'constraint' THEN 1
          WHEN 'decision' THEN 2
          WHEN 'note' THEN 3
          WHEN 'task' THEN 4
          WHEN 'entity' THEN 5
          ELSE 6
        END,
        created_at DESC
    `).all(workspace.id);

    items.forEach(item => {
      item.tags = JSON.parse(item.tags || '[]');
    });

    // Get links if requested
    let links = [];
    if (options.links !== false) {
      links = db.prepare(`
        SELECT l.*,
               cf.content as from_content, cf.type as from_type,
               ct.content as to_content, ct.type as to_type
        FROM links l
        JOIN context cf ON l.from_id = cf.id
        JOIN context ct ON l.to_id = ct.id
        WHERE cf.workspace_id = ?
      `).all(workspace.id);
    }

    // Build markdown
    const lines = [];

    lines.push(`# ${workspace.name} - Project Context`);
    lines.push('');
    lines.push(`> Generated by Substrate on ${new Date().toLocaleString()}`);
    lines.push('');

    if (options.flat) {
      // Flat format - just list everything
      items.forEach(item => {
        const tags = item.tags.length > 0 ? ` (${item.tags.join(', ')})` : '';
        lines.push(`- **[${item.type}]** ${item.content}${tags}`);
      });
    } else {
      // Sectioned format
      const constraints = items.filter(i => i.type === 'constraint');
      const decisions = items.filter(i => i.type === 'decision');
      const notes = items.filter(i => i.type === 'note');
      const tasks = items.filter(i => i.type === 'task');
      const entities = items.filter(i => i.type === 'entity');
      const other = items.filter(i => !['constraint', 'decision', 'note', 'task', 'entity'].includes(i.type));

      if (constraints.length > 0) {
        lines.push('## Constraints');
        lines.push('');
        lines.push('*Immutable facts and hard rules that must be respected.*');
        lines.push('');
        constraints.forEach(item => {
          const tags = item.tags.length > 0 ? ` \`${item.tags.join('` `')}\`` : '';
          lines.push(`- ${item.content}${tags}`);
        });
        lines.push('');
      }

      if (decisions.length > 0) {
        lines.push('## Decisions');
        lines.push('');
        lines.push('*Architectural and design choices that have been made.*');
        lines.push('');
        decisions.forEach(item => {
          const tags = item.tags.length > 0 ? ` \`${item.tags.join('` `')}\`` : '';
          lines.push(`- ${item.content}${tags}`);
        });
        lines.push('');
      }

      if (notes.length > 0) {
        lines.push('## Notes');
        lines.push('');
        notes.forEach(item => {
          const tags = item.tags.length > 0 ? ` \`${item.tags.join('` `')}\`` : '';
          lines.push(`- ${item.content}${tags}`);
        });
        lines.push('');
      }

      if (entities.length > 0) {
        lines.push('## Entities');
        lines.push('');
        lines.push('*Key domain concepts and components.*');
        lines.push('');
        entities.forEach(item => {
          const tags = item.tags.length > 0 ? ` \`${item.tags.join('` `')}\`` : '';
          lines.push(`- ${item.content}${tags}`);
        });
        lines.push('');
      }

      if (tasks.length > 0) {
        lines.push('## Tasks');
        lines.push('');
        tasks.forEach(item => {
          const tags = item.tags.length > 0 ? ` \`${item.tags.join('` `')}\`` : '';
          lines.push(`- [ ] ${item.content}${tags}`);
        });
        lines.push('');
      }

      if (other.length > 0) {
        lines.push('## Other');
        lines.push('');
        other.forEach(item => {
          const tags = item.tags.length > 0 ? ` \`${item.tags.join('` `')}\`` : '';
          lines.push(`- **[${item.type}]** ${item.content}${tags}`);
        });
        lines.push('');
      }

      // Add relationships section
      if (links.length > 0) {
        lines.push('## Relationships');
        lines.push('');
        links.forEach(link => {
          lines.push(`- ${link.from_content} → *${link.relation}* → ${link.to_content}`);
        });
        lines.push('');
      }
    }

    // Add footer
    lines.push('---');
    lines.push('');
    lines.push(`*${items.length} context items${links.length > 0 ? `, ${links.length} relationships` : ''}*`);

    const content = lines.join('\n');

    // Resolve output path
    const outputPath = resolve(process.cwd(), options.output);
    const outputDir = dirname(outputPath);

    // Ensure directory exists
    if (!existsSync(outputDir)) {
      mkdirSync(outputDir, { recursive: true });
    }

    // Write file
    writeFileSync(outputPath, content);

    success(`Exported ${items.length} items to ${options.output}`);
    if (links.length > 0) {
      dim(`  Including ${links.length} relationships`);
    }
  });
